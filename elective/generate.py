# ******************************************************************************
#
# elective:  a Python configuration loader generator
#
# Copyright 2021 Jeremy A Gray <gray@flyquackswim.com>.
#
# SPDX-License-Identifier: MIT
#
# ******************************************************************************

"""elective configuration functions."""

import textwrap


def _generate_file_banner(message=None):
    """Generate the generated file banner."""
    if message:
        return {
            "block": f'"""{message}"""',
        }
    else:
        return {
            "block": '"""Configuration module generated by elective."""',
        }


def _generate_argparse_parser(
    description="This is a configuration loader generated by elective.",
):
    """Generate an argument parser."""
    block = f"""\
def _create_argument_parser():
    \"\"\"Create an argparse argument parser.\"\"\"
    parser = argparse.ArgumentParser(
        description=\"\"\"\\
{description}
\"\"\",
    )
"""

    return {
        "dependencies": [
            "import argparse",
        ],
        "block": block,
    }


def _generate_argparse_boolean(group="parser", **kwargs):
    """Generate an ``argparse`` boolean argument."""
    block = f"""\
    {group}.add_argument(
        \"-{kwargs['short']}\",
        \"--{kwargs['long']}\",
        dest=\"{kwargs['dest']}\",
        default=None,
        action=\"{kwargs['action']}\",
        help=\"{kwargs['help']}\",
    )
"""

    return {
        "dependencies": [
            "import argparse",
        ],
        "block": block,
    }


def _generate_argparse_boolean_group(**kwargs):
    """Generate an ``argparse`` mutually exclusive boolean group."""
    block = f"    {kwargs['dest']}_group = parser.add_mutually_exclusive_group()\n"
    block += _generate_argparse_boolean(
        group=f"{kwargs['dest']}_group",
        short=kwargs["short"].lower(),
        long=kwargs["long"].lower(),
        dest=kwargs["dest"],
        default=None,
        action="store_true",
        help=kwargs["help"],
    )["block"]
    block += _generate_argparse_boolean(
        group=f"{kwargs['dest']}_group",
        short=kwargs["short"].upper(),
        long="no-" + kwargs["long"].lower(),
        dest=kwargs["dest"],
        default=None,
        action="store_false",
        help=kwargs["help"],
    )["block"]

    return {
        "dependencies": [
            "import argparse",
        ],
        "block": block,
    }


def _generate_argparse_display_action(name, message, line_length=72):
    """Generate an ``argparse`` display action option."""
    block = f"""\
    parser.add_argument(
        "--show-{name.lower()}",
        nargs=0,
        action=_show_{name.lower()}_action,
        help="Show {name.lower()}.",
    )
"""

    rendered_message = "\n\n".join(
        list(
            map(
                lambda item: "\n".join(textwrap.wrap(item.strip(), line_length)),
                textwrap.dedent(message).strip().split("\n\n"),
            )
        )
    )

    arg_class = f"""\
class _show_{name.lower()}_action(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        print(\"\"\"\\\n{rendered_message}\n\"\"\")

        parser.exit(status=0)\n\n
"""

    return {
        "block": block,
        "classes": [arg_class],
    }


def _generate_loader():
    """Generate the load configuration function."""
    block = """\
def load(argv=None):
    \"\"\"Load the configuration.\"\"\"
    args = _create_argument_parser().parse_args(argv)

    return args
"""

    return {
        "block": block,
    }


def generate(conf={}):
    """Generate a configuration loader."""
    module = {
        "preamble": "",
        "dependencies": [],
        "block": "",
        "classes": [],
    }

    message = "Configuration module generated by elective."

    module["preamble"] += _generate_file_banner(
        message=message,
    )["block"]

    try:
        parser = _generate_argparse_parser(description=conf["description"])
    except KeyError:
        parser = _generate_argparse_parser()

    module["dependencies"] += parser["dependencies"]
    module["block"] += parser["block"]

    try:
        for k in conf["option"]:
            if conf["option"][k]["type"] == "boolean":
                group = _generate_argparse_boolean_group(
                    short=conf["option"][k]["short"],
                    long=k,
                    dest=k.translate(str.maketrans("-", "_")),
                    default=None,
                    help=conf["option"][k]["help"],
                )
                module["block"] += group["block"]

        for k in conf["option"]:
            if conf["option"][k]["type"] == "display":
                disp = _generate_argparse_display_action(
                    name=k,
                    message=conf["option"][k]["message"],
                )
                module["block"] += disp["block"]
                module["classes"] += disp["classes"]
    except KeyError:
        pass

    module["block"] += "\n    return parser\n"
    module["block"] += "\n\n\n" + _generate_loader()["block"]

    return (
        module["preamble"]
        + "\n\n"
        + "\n".join(module["dependencies"])
        + "\n\n"
        + "\n\n".join(module["classes"])
        + "\n\n"
        + module["block"]
    )
